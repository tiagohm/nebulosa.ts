import { expect, test } from 'bun:test'
import { read } from './fits'

test('read', async () => {
	const fits = await read('data/fits/NGC3372-color-byte.fits')
	expect(fits!.hdus).toHaveLength(1)

	const { header, data } = fits!.hdus[0]
	expect(header.SIMPLE).toEqual({ value: true, comment: 'file does conform to FITS standard' })
	expect(header.BITPIX).toEqual({ value: 8, comment: 'number of bits per data pixel' })
	expect(header.NAXIS).toEqual({ value: 3, comment: 'number of data axes' })
	expect(header.NAXIS1).toEqual({ value: 256, comment: 'length of data axis 1' })
	expect(header.NAXIS2).toEqual({ value: 174, comment: 'length of data axis 2' })
	expect(header.NAXIS3).toEqual({ value: 3, comment: 'length of data axis 3' })
	expect(header.EXTEND).toEqual({ value: true, comment: 'FITS dataset may contain extensions' })
	expect(header.PROGRAM).toEqual({ value: 'PixInsight 1.8.9-3', comment: 'Software that created this HDU' })
	expect(header.ROWORDER).toEqual({ value: 'TOP-DOWN', comment: 'Order of pixel rows stored in the image array' })
	expect(header['DATE-OBS']).toEqual({ value: '2023-01-15T01:27:05.460', comment: 'Start date/time of observation (UTC)' })
	expect(header.EXPTIME).toEqual({ value: 30, comment: 'Exposure time in seconds' })
	expect(header.EXPOSURE).toEqual({ value: 30, comment: 'Exposure time in seconds' })
	expect(header['SET-TEMP']).toEqual({ value: -10, comment: 'CCD temperature setpoint in C' })
	expect(header['CCD-TEMP']).toEqual({ value: -10, comment: 'CCD temperature at start of exposure in C' })
	expect(header.XBINNING).toEqual({ value: 4, comment: 'Binning factor in width' })
	expect(header.YBINNING).toEqual({ value: 4, comment: 'Binning factor in height' })
	expect(header.XORGSUBF).toEqual({ value: 0, comment: 'Subframe X position in binned pixels' })
	expect(header.YORGSUBF).toEqual({ value: 0, comment: 'Subframe Y position in binned pixels' })
	expect(header.READOUTM).toEqual({ value: 'Mode0', comment: 'Readout mode of image' })
	expect(header.FILTER).toEqual({ value: 'Luminance+Red+Green+Blue' })
	expect(header.IMAGETYP).toEqual({ value: 'Light Frame', comment: 'Type of image' })
	expect(header.APTDIA).toEqual({ value: 152, comment: 'Aperture diameter of telescope in mm' })
	expect(header.APTAREA).toEqual({ value: 18145.8396720886, comment: 'Aperture area of telescope in mm^2' })
	expect(header.EGAIN).toEqual({ value: 1.00224268436432, comment: 'Electronic gain in e-/ADU' })
	expect(header.GAIN).toEqual({ value: 120 })
	expect(header.OFFSET).toEqual({ value: 30 })
	expect(header.FOCUSPOS).toEqual({ value: 1850, comment: 'Focuser position in steps' })
	expect(header.FOCUSSSZ).toEqual({ value: 10, comment: 'Focuser step size in microns' })
	expect(header.FOCUSTEM).toEqual({ value: 31.5200004577637, comment: 'Focuser temperature in deg C' })
	expect(header.OBJECT).toEqual({ value: 'NGC3372' })
	expect(header.PIERSIDE).toEqual({ value: 'WEST', comment: 'Side of pier telescope is on' })
	expect(header.JD).toEqual({ value: 2459959.56006319, comment: 'Julian Date at time of exposure' })
	expect(header['JD-HELIO']).toEqual({ value: 2459959.56036103, comment: 'Heliocentric Julian Date at time of exposure' })
	expect(header.AIRMASS).toEqual({ value: 2.05926677068602, comment: 'Relative optical path length through atmosphere' })
	expect(header.TELESCOP).toEqual({ value: '', comment: 'telescope used to acquire this image' })
	expect(header.INSTRUME).toEqual({ value: 'ASI Camera (1)' })
	expect(header.OBSERVER).toEqual({ value: '' })
	expect(header.NOTES).toEqual({ value: '' })
	expect(header.FLIPSTAT).toEqual({ value: '' })
	expect(header.HISTORY).toEqual({ value: undefined, comment: 'Dark Subtraction (Dark 19, 2072 x 1411, Bin4 x 4, Temp -10C,' })
	expect(header.CALSTAT).toEqual({ value: 'D' })
	expect(header.PEDESTAL).toEqual({ value: -100, comment: 'Correction to add for zero-based ADU' })
	expect(header.SWOWNER).toEqual({ value: 'Tiago Melo', comment: 'Licensed owner of software' })
	expect(header.INPUTFMT).toEqual({ value: 'FITS', comment: 'Format of file from which image was read' })
	expect(header.SNAPSHOT).toEqual({ value: 9, comment: 'Number of images combined' })
	expect(header.MIDPOINT).toEqual({ value: '2023-01-15T01:38:15.42', comment: 'UT of midpoint of exposure' })
	expect(header.CSTRETCH).toEqual({ value: 'High', comment: 'Initial display stretch mode' })
	expect(header.CBLACK).toEqual({ value: 103, comment: 'Initial display black level in ADUs' })
	expect(header.CWHITE).toEqual({ value: 1292, comment: 'Initial display white level in ADUs' })
	expect(header.RA).toEqual({ value: 161.0177548315, comment: 'Right ascension of the center of the image (deg' })
	expect(header.DEC).toEqual({ value: -59.6022705034, comment: 'Declination of the center of the image (deg)' })
	expect(header.TIMESYS).toEqual({ value: 'UTC', comment: 'Time scale: Universal Time, Coordinated' })
	expect(header['DATE-END']).toEqual({ value: '2023-01-15T01:27:35.460', comment: 'End date/time of observation (UTC)' })
	expect(header.OBJCTRA).toEqual({ value: '10 44 04.261', comment: 'Right ascension (hours) (compatibility)' })
	expect(header.OBJCTDEC).toEqual({ value: '-59 36 08.17', comment: 'Declination (deg) (compatibility)' })
	expect(header.CUNIT1).toEqual({ value: 'deg', comment: 'Unit of coordinates' })
	expect(header.PLTSOLVD).toEqual({ value: true, comment: 'Astrometric solved by ASTAP v2023.08.14.' })
	expect(header.DATAMIN).toEqual({ value: 0, comment: 'Minimum data value' })
	expect(header.DATAMAX).toEqual({ value: 65535, comment: 'Maximum data value' })
	expect(header.COMMENT).toEqual({ value: undefined, comment: 'FITS (Flexible Image Transport System) format is defined in \'Astronomy\nand Astrophysics\', volume 376, page 359; bibcode: 2001A&A...376..359H\nPixInsight Class Library: PCL 2.7.0\nFITS module version 1.2.0\n7  Solved in 1.5 sec. Offset 0.3". Mount offset RA=0.0", DEC=0.3"' })

	expect(data?.handle).not.toBeUndefined()
	expect(data?.size).toBe(256 * 174 * 3 * 1)
	expect(data?.offset).toBe(5760)

	await fits?.close()
})
